#!/usr/bin/env python

import os, sys

def main():
	'''
	parse command line options and take appropriate action
	'''
	import optparse
	
	# define and parse command-line options
	prog = os.path.basename(sys.argv[0])
	usage = "Usage: %s [options] action source dest" % prog
	
	parser = optparse.OptionParser(usage)
	parser.add_option("-c", "--copy",    dest="move",    action="store_true",  help="copy files to destination [default]")
	parser.add_option("-m", "--move",    dest="move",    action="store_false", help="move files to destination")
	parser.add_option("-v", "--verbose", dest="verbose", action="store_true")
	parser.add_option("-q", "--quiet",   dest="verbose", action="store_false")
	
	# sort action options
	group = optparse.OptionGroup(parser, "Sort Photos", "Usage: %s [options] sort source dest" % prog)
	group.add_option("-n", "--name",     dest="name",     help="specify a bucket name for this image source (default is the source directory name)", metavar="NAME")
	group.add_option("-p", "--preserve", dest="preserve", action="store_true",  help="keep all alternates including low-res and duplicates [default]")
	group.add_option("-d", "--discard",  dest="preserve", action="store_false", help="discard duplicates and low-res alternates.")
	parser.add_option_group(group)
	
	# restore action options
	group = optparse.OptionGroup(parser, "Restore Original Filenames", "Usage: %s [options] restore source [dest]" % prog)
	parser.add_option_group(group)
	
	# fix action options
	group = optparse.OptionGroup(parser, "Fix Photo Dates", "Usage: %s [options] fix source [dest]" % prog)
	parser.add_option_group(group)
	
	# parse our options
	parser.set_defaults(verbose=True, move=False, preserve=True)
	(options, args) = parser.parse_args()
	
	if len(args) == 0:
		parser.print_help()
		return
	elif args[0] not in ('sort','fix','restore'):
		parser.error("Invalid action provided")
	elif args[0] in ('fix','restore') and len(args) == 2:
		args.append(args[1])
	elif len(args) != 3:
		parser.error("Incorrect number of arguments")
	
	(action, src, dest) = args
	src  = src.rstrip('/\\')
	dest = dest.rstrip('/\\')
		
	# ensure source and destination both exist and are directories
	for path in (src, dest):
		if not os.path.isdir(path):
			parser.error("No such file or directory '%s'" % path)
	
	# handle sort action
	if action == 'sort':
		if not options.name:
			options.name = os.path.basename(os.path.abspath(src))
		
		name = unique_name(options.name, dest)
		if name != options.name:
			print "[WARNING] A file or directory named '%s' already exists at '%s'. Using '%s' instead." % (options.name, dest, name)
		
		sort_images(src, dest, name, options.move, options.verbose)
	
	# handle restore action
	if action == 'restore':
		restore_images(src, dest, options.move, options.verbose)
	
	# handle fix action
	if action == 'fix':
		fix_images(src, dest, options.move, options.verbose)


def sort_images(src, dest, src_bucket, move=False, verbose=True):
	'''
	sort images within src to labeled buckets within dest
	'''
	
	# generate our log closure
	logfile = dest + '/' + src_bucket + '/_sort.log.txt'
	prefix = "\nSOURCE: %s\n" % src_bucket
	log = logger(logfile, verbose, prefix)
	
	log("Sorting Images...\n\n...\n")


def restore_images(src, dest, move=False, verbose=True):
	'''
	restore image filenames generated by sort_images
	'''
	
	# generate our log closure
	log = logger(dest + '/_restore.log.txt', verbose)
	
	log("Restoring Filenames...\n\n...\n")


def fix_images(src, dest, move=False, verbose=True):
	'''
	correct image date metadata
	'''
	
	# generate our log closure
	log = logger(dest + '/_fix.log.txt', verbose)
	
	log("Fixing Image Dates...\n\n...\n")


def assert_dir(dirs, message=None):
	'''
	ensures a directory exists at each path specified in dirs.
	
	raises an exception if a directory does not exist and it is unable to create one.
	'''
	if not type(dirs) == list:
		dirs = [dirs]
	for dir in dirs:
		try:
			os.makedirs(dir)
		except OSError:
			if not os.path.isdir(dir):
				if not message:
					message = "Unable to create needed directory ('%s')" % dir
				raise IOError(message)


def unique_name(name, path):
	'''
	return a non-existing file or directory name within a given path
	
	if a suggested name already exists, appends a number to it to make it unique
	'''
	i = 1
	assert_dir(path)
	dir_list = [x.lower() for x in os.listdir(path)]
	root, ext = os.path.splitext(name)
	while name.lower() in dir_list:
		name = root + '-' + str(i) + ext
		i += 1
	return name


def logger(path, verbose=True, mirror_pretext=None):
	'''
	return a function which can be used to append to logs, enclosing the provided parameters.
	'''
	assert_dir(os.path.dirname(path))
	used = [path]
	
	def log(message, mirrors=None, echo=None):
		
		# allow echo to override verbose setting if specified
		if echo or (verbose and echo != False):
			print message
		
		if not mirrors:
			mirrors = []
		elif not type(mirrors) == list:
			mirrors = [mirrors]
		
		logfiles = [path] + mirrors
		for logfile in logfiles:
			with open(logfile, 'a') as res:
				if not (logfile in used):
					used.append(logfile)
					if mirror_pretext:
						res.write(mirror_pretext + "\n")
				res.write(message + "\n")
	return log


if __name__ == "__main__":
	try:
		main()
	except KeyboardInterrupt:
		print "\nOpteration Aborted\n"